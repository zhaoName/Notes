# 粘包


<br>

### 0x01 为什么会造成粘包？

TCP 是面向字节流的通信协议，TCP 会对每个字节进行编号，且它能保证发送方以什么顺序发送字节流，接收方就能以什么顺序收到。

面向字节流的概念可以这么理解：发送方一次或多次发送 "abc, 123, defghi, 456..." 这些数据，接收方每次接收时得到的数据可能是 "abc1, 23de, fghi45, 6..." 这样的片段，也可能是 "abc123, de, fgh, i456 ..." 这样的片段。TCP 虽然能保证数据按序到达对方，但不保证每次到达的数据量跟发送的时候是一致的。

所以当应用层从 TCP 的缓冲区中读取数据时, 由于流数据没有边界区分，就不能分辨 "abc123" 是两个数据包，"de" 不是一个完整的数据。

所以粘包是用 TCP 写应用层协议的人连 TCP 是字节流协议都没搞明白就乱写而产生的一种低级错误。

**粘包是如何发生的：**

- TCP 协议是面向字节流的协议，它可能会组合或者拆分应用层协议的数据；

- 应用层协议的没有定义消息的边界导致数据的接收方无法拼接数据。

<br>

### 解决办法

在应用层中定义消息的边界，那么无论 TCP 协议如何对应用层协议的数据包进程拆分和重组，接收方都能根据协议的规则恢复对应的消息。在应用层协议中，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）。如大名鼎鼎是的 HTTP 协议就带有带 header 和 body，header 里有 Content-Length 字段，指定 body 的大小。

<br>

### 为什么基于 UDP 不会粘包

UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。

如发送方一次或分多次发送 "abc, 123, defghi, 456..." 这些数据，接收方要么收不到包（譬如 123 这个包，要丢就是整体都丢了，不可能收到了 1，而丢了23），要是收到的话，也会是这样一个个完整的包（顺序不保证）：123，abc, 456, defghi....，所以每个包都是一个整体，是最小传输单元，不可再被分解。

所以在应用层收到的数据 UDP 的数据不用担心多个数据包黏在一起的情况。


<br>


<br>


<br>

