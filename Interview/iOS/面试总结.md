
## 离屏渲染

### 0x01 什么是离屏渲染？

在当前屏幕缓冲区之外，重新开辟一个缓冲区进行渲染操作。离屏渲染发生在 GPU 层面上，会创建新的渲染缓冲区，会触发 OpenGL 的多通道渲染管线，图形上下文的切换会造成额外的开销，增加 GPU 工作量。如果 CPU GPU 累计耗时 16.67 毫秒还没有完成，就会造成卡顿掉帧。

对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作。

### 0x02 什么情况会导致离屏渲染 ？

- `cornerRadius + clipsToBounds`

- `layer.shadow` 阴影

- `CALayer`的`allowsGroupOpacity ` 

- `mask`

- `UIBlurEffect` 模糊效果

- `allowsEdgeAntialiasing` 抗锯齿

- `shouldRasterize `

- 渐变效果

- `drawRect`

### 0x03 如何检测离屏渲染

- 模拟器 Debug 中选中 Color Off-screen Rendered, 离屏渲染的图层高亮成黄

- 真机 Instruments -> Core Animation, 勾选 Color Off-screen Rendered Yellow

### 0x04 善用离屏渲染

CALayer为这个方案提供了对应的解法：`shouldRasterize`。一旦被设置为true，Render Server就会强制把layer的渲染结果（包括其子layer，以及圆角、阴影、group opacity等等）保存在一块内存中，这样一来在下一帧仍然可以被复用，而不会再次触发离屏渲染。有几个需要注意的点：

- `shouldRasterize`的主旨在于降低性能损失，但总是至少会触发一次离屏渲染。如果你的layer本来并不复杂，也没有圆角阴影等等，打开这个开关反而会增加一次不必要的离屏渲染

- 离屏渲染缓存有空间上限，最多不超过屏幕总像素的2.5倍大小

- 一旦缓存超过100ms没有被使用，会自动被丢弃

- layer的内容（包括子layer）必须是静态的，因为一旦发生变化（如resize，动画），之前辛苦处理得到的缓存就失效了。如果这件事频繁发生，我们就又回到了“每一帧都需要离屏渲染”的情景，而这正是开发者需要极力避免的。针对这种情况，Xcode提供了"Color Hits Green and Misses Red"的选项，帮助我们查看缓存的使用是否符合预期

- 其实除了解决多次离屏渲染的开销，`shouldRasterize`在另一个场景中也可以使用：如果layer的子结构非常复杂，渲染一次所需时间较长，同样可以打开这个开关，把layer绘制到一块缓存，然后在接下来复用这个结果，这样就不需要每次都重新绘制整个layer树了


### 0x05 离屏渲染优化

- 对于所有的阴影，使用shadowPath来规避离屏渲染

```
view.layer.shadowPath = [UIBezierPath pathWithCGRect:view.bounds].CGPath
```

- 对于图片的圆角，统一采用不经由容器来做剪切，而是预先使用`CoreGraphics`为图片裁剪圆角

- 对于view的圆形边框，如果没有`backgroundColor`，可以放心使用`cornerRadius`来做,若必须`clipsToBounds `，则图片的圆角也需用`CoreGraphics `裁剪

- 对于特殊形状的view，使用layer mask并打开`shouldRasterize`来对渲染结果进行缓存


**参考:** 

[关于iOS离屏渲染的深入研究](https://zhuanlan.zhihu.com/p/72653360)

[iOS离屏渲染](https://www.todayios.com/ios-off-screen-render/)



<br>


## APP 冷启动优化

### 0x01 `pre-main` 阶段

`pre-main`阶段指的是从用户唤起 App 到`main()`函数执行之前的过程。

可以在`Xcode -> Edit Scheme -> Run -> Arguments -> Environment Variables`中添加`DYLD_PRINT_STATISTICS or DYLD_PRINT_STATISTICS_DETAILS ` 为 1, 查看`pre-main` 阶段的耗时情况


<br>

## iOS 中内省的几个方法有哪些？内部实现原理是什么？






